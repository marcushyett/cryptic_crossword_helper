<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{TITLE}}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(15, 30px);
            grid-template-rows: repeat(15, 30px);
            gap: 1px;
            border: 2px solid #000;
            background: #000;
            width: fit-content;
        }
        .cell {
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            width: 30px;
            height: 30px;
        }
        .cell.blank {
            background: black;
        }
        .cell .number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: #666;
        }
        .clues {
            flex: 1;
            min-width: 0;
        }
        .clue-group {
            margin-bottom: 20px;
        }
        .clue {
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #ddd;
            cursor: pointer;
            word-wrap: break-word;
        }
        .clue:hover {
            background: #f0f0f0;
        }
        .clue.revealed {
            background: #e0ffe0;
        }
        .reveal-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 5px;
            display: inline-block;
        }
        .reveal-btn:hover {
            background: #0056b3;
        }
        .hint-btn { background: #6f42c1; }
        .hint-btn:hover { background: #5a35a1; }
        .help-btn { background: #6f42c1; }
        .help-btn:hover { background: #5a35a1; }
        .help-panel {
            margin-top: 8px; border: 1px solid #ddd; border-radius: 6px; padding: 8px; background: #fafafa;
        }
        .help-header { display: flex; gap: 6px; margin-bottom: 6px; }
        .pill { padding: 4px 8px; border: 1px solid #ccc; border-radius: 999px; cursor: pointer; background: #fff; font-size: 12px; }
        .pill.active { background: #e9f0ff; border-color: #7ba7ff; }
        .help-content { font-size: 13px; color: #333; }
        .hint-item { margin: 4px 0; }
        .explain-step { margin: 4px 0; }
        .token-indicator { background: #fff3cd; }
        .token-fodder { background: #e2f0d9; }
        .token-definition { background: #fde2e2; }
        .reveal-word-btn {
            background: #dc3545;
        }
        .reveal-word-btn:hover {
            background: #c82333;
        }
        .check-btn {
            background: #28a745;
        }
        .check-btn:hover {
            background: #218838;
        }
        .answer {
            display: none;
            font-weight: bold;
            color: #007bff;
        }
        .clue.revealed .answer {
            display: inline;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                flex-direction: column;
                gap: 10px;
            }
            .grid {
                grid-template-columns: repeat(15, 24px);
                grid-template-rows: repeat(15, 24px);
                margin: 0 auto;
            }
            .cell {
                width: 24px;
                height: 24px;
                font-size: 14px;
            }
            .cell .number {
                font-size: 8px;
                top: 1px;
                left: 1px;
            }
            .clues {
                width: 100%;
            }
            .clue {
                padding: 8px;
                font-size: 14px;
            }
            .reveal-btn {
                padding: 4px 8px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            .grid {
                grid-template-columns: repeat(15, 20px);
                grid-template-rows: repeat(15, 20px);
            }
            .cell {
                width: 20px;
                height: 20px;
                font-size: 12px;
            }
            .cell .number {
                font-size: 7px;
            }
            h1 {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <h1>{{TITLE}}</h1>
    <div style="margin-bottom: 10px;">
        <button id="clearGridBtn" style="background: #6c757d; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px;">Clear Grid</button>
    </div>
    <div class="container">
        <div class="grid" id="grid"></div>
        <div class="clues" id="clues"></div>
    </div>

    <script>
        const gameData = {{GAME_DATA}};
    let hintsData = {}; // { word_id: [hint1, hint2, hint3] }
    let explData = {}; // { word_id: { device, steps:[], highlights:[{role,text}] } }

        let gridState = {};
        let revealedClues = new Set();
    let revealedLetters = {}; // Track revealed letters per word
    let revealedHints = {}; // { wordId: Set of indices revealed }
    const HINTS_STATE_VERSION = 'v2'; // bump to reset old auto-revealed states
        let storageKey = '';

        async function init() {
            // Create unique storage key based on puzzle title
            storageKey = 'crossword_' + gameData.title.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
            
            loadState(); // Load saved state first
            await loadHints();
            await loadExplanations();
            createGrid();
            createClues();
            
            // Add clear grid button functionality
            document.getElementById('clearGridBtn').addEventListener('click', clearGrid);
        }

        async function loadHints() {
            try {
                const res = await fetch('hints.json', { cache: 'no-store' });
                if (!res.ok) return;
                const json = await res.json();
                hintsData = json || {};
            } catch (e) {
                // no-op if not available
                hintsData = {};
            }
        }

        async function loadExplanations() {
            try {
                const res = await fetch('explanations.json', { cache: 'no-store' });
                if (!res.ok) return;
                const json = await res.json();
                explData = json || {};
            } catch (e) {
                explData = {};
            }
        }

        function createGrid() {
            const gridEl = document.getElementById('grid');
            gameData.grid.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const cellEl = document.createElement('div');
                    cellEl.className = 'cell';
                    if (cell.Blank === 'blank') {
                        cellEl.classList.add('blank');
                    } else {
                        cellEl.textContent = gridState[`${rowIndex}-${colIndex}`] || '';
                        cellEl.contentEditable = true;
                        cellEl.addEventListener('input', (e) => {
                            const value = e.target.textContent.toUpperCase();
                            e.target.textContent = value.slice(-1); // Only last character
                            gridState[`${rowIndex}-${colIndex}`] = value.slice(-1);
                            saveState();
                        });
                        if (cell.Number) {
                            const numEl = document.createElement('div');
                            numEl.className = 'number';
                            numEl.textContent = cell.Number;
                            cellEl.appendChild(numEl);
                        }
                    }
                    gridEl.appendChild(cellEl);
                });
            });
        }

        function createClues() {
            const cluesEl = document.getElementById('clues');
            const groups = {};
            
            gameData.clues.forEach(clue => {
                if (!groups[clue.direction]) {
                    groups[clue.direction] = [];
                }
                groups[clue.direction].push(clue);
            });

            Object.keys(groups).forEach(direction => {
                const groupEl = document.createElement('div');
                groupEl.className = 'clue-group';
                groupEl.innerHTML = `<h3>${direction.charAt(0).toUpperCase() + direction.slice(1)}</h3>`;
                
                groups[direction].forEach(clue => {
                    const clueEl = document.createElement('div');
                    clueEl.className = 'clue';
                    clueEl.dataset.wordId = clue.word_id;
                    
                    const revealBtn = document.createElement('button');
                    revealBtn.className = 'reveal-btn';
                    revealBtn.textContent = 'Reveal Letter';
                    revealBtn.addEventListener('click', () => revealLetter(clue));

                    const revealWordBtn = document.createElement('button');
                    revealWordBtn.className = 'reveal-btn reveal-word-btn';
                    revealWordBtn.textContent = 'Reveal Word';
                    revealWordBtn.addEventListener('click', () => revealAnswer(clue));

                    const checkBtn = document.createElement('button');
                    checkBtn.className = 'reveal-btn check-btn';
                    checkBtn.textContent = 'Check Solution';
                    checkBtn.addEventListener('click', () => checkSolution(clue));

                    const helpBtn = document.createElement('button');
                    helpBtn.className = 'reveal-btn help-btn';
                    helpBtn.textContent = 'Help';
                    helpBtn.addEventListener('click', () => toggleHelp(clue, clueEl));
                    
                    clueEl.innerHTML = `
                        <strong>${clue.number}.</strong> ${clue.clue} (${clue.length})
                        <span class="answer"> (${clue.answer})</span>
                    `;
                    clueEl.appendChild(revealBtn);
                    clueEl.appendChild(checkBtn);
                    clueEl.appendChild(helpBtn);
                    clueEl.appendChild(revealWordBtn);
                    
                    if (revealedClues.has(clue.word_id)) {
                        clueEl.classList.add('revealed');
                        fillGridWithAnswer(clue);
                    } else if (revealedLetters[clue.word_id]) {
                        // Fill in revealed letters for this word
                        const positions = getWordPositions(clue.word_id);
                        revealedLetters[clue.word_id].forEach(index => {
                            const [row, col] = positions[index];
                            const cellEl = document.querySelector(`.grid .cell:nth-child(${row * 15 + col + 1})`);
                            if (cellEl && !cellEl.classList.contains('blank')) {
                                cellEl.textContent = clue.answer[index];
                                gridState[`${row}-${col}`] = clue.answer[index];
                            }
                        });
                    }
                    
                    groupEl.appendChild(clueEl);
                });
                
                cluesEl.appendChild(groupEl);
            });
        }

    function revealHint(clue, index, holderEl, btnEl) {
            const wordId = String(clue.word_id);
            const hints = hintsData[wordId];
            if (!hints || !Array.isArray(hints) || !hints[index]) {
                alert('No hint available.');
                return;
            }
            if (!revealedHints[wordId]) revealedHints[wordId] = new Set();
            if (revealedHints[wordId].has(index)) {
                // Already revealed; ensure it's visible
                const text = hintsData[wordId] && hintsData[wordId][index] ? hintsData[wordId][index] : '';
                if (holderEl && !holderEl.textContent) holderEl.textContent = text ? ` ${text}` : ' (no hint available)';
                return;
            }
            revealedHints[wordId].add(index);
            const text = hintsData[wordId] && hintsData[wordId][index] ? hintsData[wordId][index] : '';
            if (holderEl) holderEl.textContent = text ? ` ${text}` : ' (no hint available)';
            if (btnEl) btnEl.disabled = true;
            saveState();
        }
        // intentionally no inline list rendering to prevent default hint reveal

        function toggleHelp(clue, clueEl) {
            const existing = clueEl.querySelector('.help-panel');
            if (existing) { existing.remove(); return; }
            const panel = document.createElement('div');
            panel.className = 'help-panel';
            const header = document.createElement('div');
            header.className = 'help-header';
            const pillHints = document.createElement('div'); pillHints.className = 'pill active'; pillHints.textContent = 'Hints';
            const pillExpl = document.createElement('div'); pillExpl.className = 'pill'; pillExpl.textContent = 'Explanation';
            header.appendChild(pillHints); header.appendChild(pillExpl);
            const content = document.createElement('div'); content.className = 'help-content';

            function renderHints() {
                content.innerHTML = '';
                const list = document.createElement('div'); list.className = 'hints';
                for (let i = 0; i < 3; i++) {
                    const row = document.createElement('div'); row.className = 'hint-item';
                    const btn = document.createElement('button'); btn.className = 'reveal-btn hint-btn'; btn.textContent = `Reveal hint ${i+1}`;
                    const holder = document.createElement('span'); holder.style.marginLeft = '8px';
                    row.appendChild(btn); row.appendChild(holder);
                    btn.addEventListener('click', () => {
                        revealHint(clue, i, holder, btn);
                    });
                    // Pre-fill if already revealed
                    const wid = String(clue.word_id);
                    if (revealedHints[wid] && revealedHints[wid].has(i)) {
                        const text = (hintsData[wid] && hintsData[wid][i]) ? hintsData[wid][i] : '';
                        holder.textContent = text ? ` ${text}` : ' (no hint available)';
                        btn.disabled = true;
                    }
                    list.appendChild(row);
                }
                content.appendChild(list);
            }

            function renderExplanation() {
                content.innerHTML = '';
                const wid = String(clue.word_id);
                const expl = explData[wid];
                if (!expl) {
                    content.textContent = 'No explanation available.';
                    return;
                }
                // Device badge and legend for colors
                if (expl.device) {
                    const device = document.createElement('div');
                    device.style.marginBottom = '6px';
                    device.innerHTML = `<span style="display:inline-block;padding:2px 6px;border:1px solid #ccc;border-radius:12px;background:#fff;font-size:12px;">Device: ${expl.device}</span>`;
                    content.appendChild(device);
                }
                const legend = document.createElement('div');
                legend.style.display = 'flex'; legend.style.gap = '8px'; legend.style.alignItems = 'center'; legend.style.margin = '6px 0'; legend.style.fontSize = '12px';
                legend.innerHTML = `
                    <span><span style="display:inline-block;width:10px;height:10px;background:#fff3cd;border:1px solid #e6c200;margin-right:4px;"></span>Indicator</span>
                    <span><span style="display:inline-block;width:10px;height:10px;background:#e2f0d9;border:1px solid #9ac27a;margin-right:4px;"></span>Fodder</span>
                    <span><span style="display:inline-block;width:10px;height:10px;background:#fde2e2;border:1px solid #f2a0a0;margin-right:4px;"></span>Definition</span>
                `;
                content.appendChild(legend);
                // Steps
                if (Array.isArray(expl.steps)) {
                    expl.steps.forEach((s, idx) => {
                        const p = document.createElement('div'); p.className = 'explain-step';
                        const clean = String(s).replace(/^\s*[0-9]+\./, '').trim();
                        p.textContent = `${idx + 1}. ${clean}`;
                        content.appendChild(p);
                    });
                }
                // Simple token highlighting within the clue text area
                try {
                    const clueText = `${clue.clue}`;
                    let highlighted = clueText;
                    if (Array.isArray(expl.highlights)) {
                        expl.highlights.forEach(h => {
                            const cls = h.role === 'indicator' ? 'token-indicator' : h.role === 'fodder' ? 'token-fodder' : 'token-definition';
                            const re = new RegExp(h.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                            highlighted = highlighted.replace(re, (m) => `<span class="${cls}">${m}</span>`);
                        });
                    }
                    const cluePreview = document.createElement('div');
                    cluePreview.style.marginTop = '8px';
                    cluePreview.innerHTML = `<em>${highlighted}</em>`;
                    content.appendChild(cluePreview);
                } catch (_) {}
            }

            pillHints.addEventListener('click', () => { pillHints.classList.add('active'); pillExpl.classList.remove('active'); renderHints(); });
            pillExpl.addEventListener('click', () => { pillExpl.classList.add('active'); pillHints.classList.remove('active'); renderExplanation(); });

            panel.appendChild(header);
            panel.appendChild(content);
            clueEl.appendChild(panel);
            renderHints();
        }

        function checkSolution(clue) {
            const wordId = clue.word_id;
            const positions = getWordPositions(wordId);
            let correctCount = 0;
            let totalCount = positions.length;
            
            // Check each position
            positions.forEach((pos, index) => {
                const [row, col] = pos;
                const currentLetter = gridState[`${row}-${col}`] || '';
                const correctLetter = clue.answer[index];
                
                if (currentLetter.toUpperCase() === correctLetter.toUpperCase()) {
                    correctCount++;
                }
            });
            
            const percentage = Math.round((correctCount / totalCount) * 100);
            const isCorrect = correctCount === totalCount;
            
            // Show result
            const result = isCorrect 
                ? `✅ Correct! (100% correct)`
                : `❌ Incorrect. ${percentage}% correct (${correctCount}/${totalCount} letters)`;
            
            alert(result);
        }

        function revealLetter(clue) {
            const wordId = clue.word_id;
            
            // Initialize revealed letters for this word if not exists
            if (!revealedLetters[wordId]) {
                revealedLetters[wordId] = new Set();
            }
            
            const positions = getWordPositions(wordId);
            const availablePositions = [];
            
            // Find positions that are either empty or have incorrect letters
            positions.forEach((pos, index) => {
                const [row, col] = pos;
                const currentLetter = gridState[`${row}-${col}`] || '';
                const correctLetter = clue.answer[index];
                
                if (currentLetter !== correctLetter) {
                    availablePositions.push({ pos, index, correctLetter });
                }
            });
            
            if (availablePositions.length === 0) {
                // All letters are correct, mark as fully revealed
                revealedClues.add(wordId);
                const clueEl = document.querySelector(`[data-word-id="${wordId}"]`);
                clueEl.classList.add('revealed');
                saveState();
                return;
            }
            
            // Randomly select one of the available positions
            const randomIndex = Math.floor(Math.random() * availablePositions.length);
            const selected = availablePositions[randomIndex];
            
            // Fill the selected position with the correct letter
            const [row, col] = selected.pos;
            const cellEl = document.querySelector(`.grid .cell:nth-child(${row * 15 + col + 1})`);
            if (cellEl && !cellEl.classList.contains('blank')) {
                cellEl.textContent = selected.correctLetter;
                gridState[`${row}-${col}`] = selected.correctLetter;
                revealedLetters[wordId].add(selected.index);
            }
            
            saveState();
        }

        function fillGridWithAnswer(clue) {
            const word = gameData.grid.flat().find(cell => 
                cell.WordAcrossID == clue.word_id || cell.WordDownID == clue.word_id
            );
            if (!word) return;
            
            const positions = getWordPositions(clue.word_id);
            positions.forEach((pos, index) => {
                const [row, col] = pos;
                const cellEl = document.querySelector(`.grid .cell:nth-child(${row * 15 + col + 1})`);
                if (cellEl && !cellEl.classList.contains('blank')) {
                    cellEl.textContent = clue.answer[index];
                    gridState[`${row}-${col}`] = clue.answer[index];
                }
            });
        }

        function revealAnswer(clue) {
            const wordId = clue.word_id;
            revealedClues.add(wordId);
            const clueEl = document.querySelector(`[data-word-id="${wordId}"]`);
            clueEl.classList.add('revealed');
            fillGridWithAnswer(clue);
            saveState();
        }

        function getWordPositions(wordId) {
            const word = gameData.grid.flat().filter(cell => 
                cell.WordAcrossID == wordId || cell.WordDownID == wordId
            );
            return word.map(cell => {
                const row = Math.floor((cell.SquareID - 1) / 15);
                const col = (cell.SquareID - 1) % 15;
                return [row, col];
            });
        }

        function saveState() {
            localStorage.setItem(storageKey, JSON.stringify({
                grid: gridState,
                revealed: Array.from(revealedClues),
                revealedLetters: Object.fromEntries(
                    Object.entries(revealedLetters).map(([key, set]) => [key, Array.from(set)])
                ),
                revealedHints: Object.fromEntries(
                    Object.entries(revealedHints).map(([key, set]) => [key, Array.from(set)])
                ),
                hintsStateVersion: HINTS_STATE_VERSION
            }));
        }

        function loadState() {
            const state = localStorage.getItem(storageKey);
            if (state) {
                const parsed = JSON.parse(state);
                gridState = parsed.grid || {};
                revealedClues = new Set(parsed.revealed || []);
                revealedLetters = {};
                revealedHints = {};
                if (parsed.revealedLetters) {
                    Object.entries(parsed.revealedLetters).forEach(([key, arr]) => {
                        revealedLetters[key] = new Set(arr);
                    });
                }
                if (parsed.hintsStateVersion !== HINTS_STATE_VERSION) {
                    revealedHints = {};
                } else if (parsed.revealedHints) {
                    Object.entries(parsed.revealedHints).forEach(([key, arr]) => {
                        revealedHints[key] = new Set(arr);
                    });
                }
                
                // Update cells with loaded state
                Object.entries(gridState).forEach(([key, letter]) => {
                    const [row, col] = key.split('-').map(Number);
                    const cellEl = document.querySelector(`.grid .cell:nth-child(${row * 15 + col + 1})`);
                    if (cellEl) {
                        cellEl.textContent = letter;
                    }
                });
            }
        }

        function clearGrid() {
            if (confirm('Are you sure you want to clear the entire grid? This will remove all your progress.')) {
                gridState = {};
                revealedClues = new Set();
                revealedLetters = {};
                
                // Clear all cells
                document.querySelectorAll('.grid .cell').forEach(cell => {
                    if (!cell.classList.contains('blank')) {
                        cell.textContent = '';
                    }
                });
                
                // Reset clue styles
                document.querySelectorAll('.clue').forEach(clue => {
                    clue.classList.remove('revealed');
                });
                
                // Clear local storage
                localStorage.removeItem(storageKey);
            }
        }

        init();
    </script>
</body>
</html>
